package cs1501_p5;

import java.util.HashMap;
import java.util.Map;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;
import java.util.HashSet;
import java.util.Set;

public class ClusteringMapGenerator implements ColorMapGenerator_Inter {
    private DistanceMetric_Inter distanceMetric;

    // constructor that accepts an object that is a subtype of DistanceMetric_Inter
    // That is, when instantiating ClusteringMapGenerator, one must specify an
    // object that can be used (via the colorDistance method)
    // to determine the distance between two colors, each represented as an instance
    // of Pixel.
    public ClusteringMapGenerator(DistanceMetric_Inter metric) {

        this.distanceMetric = metric;

    }

    /**
     * Produces an initial palette. For bucketing implementations, the initial
     * palette will be the centers of the evenly-divided buckets. For clustering
     * implementations, the initial palette will be the initial centroids. When
     * needed, a distance metric should be specified when the color map
     * generator is constructed.
     *
     * @param pixelArray the 2D Pixel array that represents a bitmap image
     * @param numColors  the number of desired colors in the palette
     * @return a Pixel array containing numColors elements
     */
    public Pixel[] generateColorPalette(Pixel[][] pixelArray, int numColors){
        if (numColors <= 0) {
            throw new IllegalArgumentException("Number of colors must be positive");
        }

        Set<Pixel> uniquePixels = new HashSet<>();
        for (Pixel[] row : pixelArray) {
            for (Pixel pixel : row) {
                uniquePixels.add(pixel);
            }
        }
        
        List<Pixel> uniquePixelList = new ArrayList<>(uniquePixels);
        Pixel[] palette = new Pixel[numColors];
        if (uniquePixelList.isEmpty()) {
            return palette;
        }

        palette[0]=pixelArray[0][0];
        // Select remaining centroids using farthest-first traversal
        for(int k = 1; k < numColors && k < uniquePixelList.size(); k++){
            Pixel farthestPixel = null;
            double maxMinDistance = -1;

            // For each pixel, find its distance to the closest centroid
            for(Pixel pixel: uniquePixelList){
                
                double minDistance = Double.MAX_VALUE;

                for(int i=0; i<k; i++){
                    double distance=distanceMetric.colorDistance(pixel, palette[i]);
                    if(distance<minDistance){
                        minDistance=distance;
                    }

                }

                // If this pixel is farther from its closest centroid than any we've seen so far,
                // or is the same distance but has a higher RGB value, select it
                boolean isNewFarthest = minDistance > maxMinDistance;
                boolean isthesamedistancebuthasahigherRGBvalue= ((maxMinDistance==minDistance) && farthestPixel != null && pixelToInt(pixel)>pixelToInt(farthestPixel));


                if (isNewFarthest || isthesamedistancebuthasahigherRGBvalue ) {
                    maxMinDistance = minDistance;
                    farthestPixel = pixel;

                }


            }
            // Add the farthest pixel as the next centroid
            palette[k]=farthestPixel;

        }

        return palette;


    }

    private int pixelToInt(Pixel pixel) {
        return ((pixel.getRed() << 16) & 0xff0000) | ((pixel.getGreen() << 8) & 0xff0000) | (pixel.getBlue() & 0xff);
    }

    /**
     * Computes the reduced color map. For bucketing implementations, this will
     * map each color to the center of its bucket. For clustering
     * implementations, this will map each color to its final centroid. When
     * needed, a distance metric should be specified when the color map
     * generator is constructed.
     *
     * @param pixelArray          the pixels array that represents a bitmap image
     * @param initialColorPalette an initial color palette, such as those
     *                            generated by generateColorPalette, represented as
     *                            an array of Pixels
     * @return A Map that maps each distinct color in pixelArray to a final
     *         color
     */
    // This method should implement the naivek-means clustering algorithm we
    // discussed in lecture
    // (Lloydâ€™s algorithm). The initialColorPalette parameter identifies the
    // starting k centroids. This clustering should produce a
    // final color palette and then return a map of each distinct color in
    // pixelArray to its value in the final color palette.
    public Map<Pixel, Pixel> generateColorMap(Pixel[][] pixelArray, Pixel[] initialColorPalette) {
        // Get all unique pixels
        Set<Pixel> uniquePixels = new HashSet<>();
        for (Pixel[] row : pixelArray) {
            for (Pixel pixel : row) {
                uniquePixels.add(pixel);
            }
        }
        
        List<Pixel> uniquePixelList = new ArrayList<>(uniquePixels);
        int numColors = initialColorPalette.length;
        
        // Start with the initial palette
        Pixel[] currentPalette = new Pixel[numColors];
        System.arraycopy(initialColorPalette, 0, currentPalette, 0, numColors);
        
        
        boolean centroidsChanged = true;
        int maxIterations = 10000;  // Prevent infinite loops
        int iteration = 0;
        
        // Maps for assignment of pixels to clusters
        Map<Pixel, List<Pixel>> clusters = new HashMap<>();
        
        // K-means iteration
        while (centroidsChanged && iteration < maxIterations) {
            // Reset clusters
            clusters.clear();
            for (int i = 0; i < numColors; i++) {
                clusters.put(currentPalette[i], new ArrayList<>());
            }
            
            // Assign each pixel to the closest centroid (cluster)
            for (Pixel pixel : uniquePixelList) {
                double minDistance = Double.MAX_VALUE;
                Pixel closestCentroid = null;
                
                for (Pixel centroid : currentPalette) {
                    if (centroid == null) continue;
                    
                    double distance = distanceMetric.colorDistance(pixel, centroid);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestCentroid = centroid;
                    }
                }
                
                if (closestCentroid != null) {
                    clusters.get(closestCentroid).add(pixel);
                }
            }
            
            // Calculate new centroids by averaging the pixels in each cluster
            centroidsChanged = false;
            for (int i = 0; i < numColors; i++) {
                List<Pixel> cluster = clusters.get(currentPalette[i]);
                
                if (!cluster.isEmpty()) {
                    // Calculate average RGB values
                    long sumR = 0, sumG = 0, sumB = 0;
                    for (Pixel pixel : cluster) {
                        sumR += pixel.getRed();
                        sumG += pixel.getGreen();
                        sumB += pixel.getBlue();
                    }
                    
                    int avgR = (int)(sumR / cluster.size());
                    int avgG = (int)(sumG / cluster.size());
                    int avgB = (int)(sumB / cluster.size());
                    
                    Pixel newCentroid = new Pixel(avgR, avgG, avgB);
                    
                    // Check if centroid changed
                    if (!newCentroid.equals(currentPalette[i])) {
                        currentPalette[i] = newCentroid;
                        centroidsChanged = true;
                    }
                }
            }
            
            iteration++;
        }
        
        // Create a map from each original pixel to its closest centroid in the final palette
        Map<Pixel, Pixel> colorMap = new HashMap<>();
        for (Pixel pixel : uniquePixelList) {
            Pixel closestCentroid = null;
            double minDistance = Double.MAX_VALUE;
            
            for (Pixel centroid : currentPalette) {
                if (centroid == null) continue;
                
                double distance = distanceMetric.colorDistance(pixel, centroid);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestCentroid = centroid;
                }
            }
            
            colorMap.put(pixel, closestCentroid);
        }
        
        return colorMap;

    }

}
